{"version":3,"sources":["Attachment.js","ImBackButton.js","MessageBackButton.js","PostBackButton.js","CardActionButton.js","SuggestedActions.js","util/getValueOrUndefined.js","PlainWebChat.js","serviceWorker.js","index.js","App.js"],"names":["Attachment","content","contentUrl","contentType","name","alt","src","href","rel","target","JSON","stringify","useSendMessage","hooks","ImBackButton","cardAction","title","value","sendMessage","handleClick","useCallback","onClick","type","useSendMessageBack","MessageBackButton","displayText","text","sendMessageBack","useSendPostBack","PostBackButton","sendPostBack","useSuggestedActions","SuggestedActions","suggestedActions","length","map","index","key","CardActionButton","getValueOrUndefined","object","path","shift","console","log","useActivities","PlainWebChat","activities","useState","sendBoxValue","setSendBoxValue","handleChange","handleSubmit","event","preventDefault","filter","channelData","postBack","from","role","activity","attachments","Fragment","id","textFormat","attachment","onSubmit","autoFocus","onChange","Boolean","window","location","hostname","match","ReactDOM","render","React","directLine","setDirectLine","a","async","fetch","method","res","json","token","getDirectLineToken","then","createDirectLine","Composer","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.7284375b.chunk.js","sourcesContent":["import React from 'react';\n\nconst Attachment = ({ content, contentUrl, contentType, name }) => {\n  switch (contentType) {\n    case 'image/gif':\n    case 'image/jpeg':\n    case 'image/png':\n    case 'image/svg':\n    case 'image/svg+xml':\n      return <img alt={name} src={contentUrl} />;\n\n    case 'text/markdown':\n    case 'text/plain':\n      return <p>{content}</p>;\n\n    default:\n      if (contentUrl) {\n        return (\n          <a href={contentUrl} rel=\"noopener noreferrer\" target=\"_blank\">\n            {name}\n          </a>\n        );\n      } else {\n        return <pre>{JSON.stringify(content, null, 2)}</pre>;\n      }\n  }\n};\n\nexport default Attachment;\n","import { hooks } from 'botframework-webchat-component';\nimport React, { useCallback } from 'react';\n\nconst { useSendMessage } = hooks;\n\nconst ImBackButton = ({ cardAction: { title, value } }) => {\n  const sendMessage = useSendMessage();\n  const handleClick = useCallback(() => sendMessage(value), [value, sendMessage]);\n\n  return (\n    <button\n      // ImBack is essentially sending a message\n      onClick={handleClick}\n      type=\"button\"\n    >\n      ImBack: {title}\n    </button>\n  );\n};\n\nexport default ImBackButton;\n","import { hooks } from 'botframework-webchat-component';\nimport React, { useCallback } from 'react';\n\nconst { useSendMessageBack } = hooks;\n\nconst MessageBackButton = ({ cardAction: { displayText, text, title, value } }) => {\n  const sendMessageBack = useSendMessageBack();\n\n  const handleClick = useCallback(() => sendMessageBack(value, text, displayText), [\n    displayText,\n    sendMessageBack,\n    text,\n    value\n  ]);\n\n  return (\n    <button\n      // Web Chat does the heavylifting for us by exposing a \"sendMessageBack\" function.\n      // We do need to handle \"displayText\" manually in our renderer though.\n      onClick={handleClick}\n      type=\"button\"\n    >\n      MessageBack: {title}\n    </button>\n  );\n};\n\nexport default MessageBackButton;\n","import { hooks } from 'botframework-webchat-component';\nimport React, { useCallback } from 'react';\n\nconst { useSendPostBack } = hooks;\n\nconst PostBackButton = ({ cardAction: { title, value } }) => {\n  const sendPostBack = useSendPostBack();\n  const handleClick = useCallback(() => sendPostBack(value), [value, sendPostBack]);\n\n  return (\n    <button\n      // Web Chat does the heavylifting for us by exposing a \"sendPostBack\" function.\n      onClick={handleClick}\n      type=\"button\"\n    >\n      PostBack: {title}\n    </button>\n  );\n};\n\nexport default PostBackButton;\n","import React from 'react';\n\nimport ImBackButton from './ImBackButton';\nimport MessageBackButton from './MessageBackButton';\nimport PostBackButton from './PostBackButton';\n\n// \"cardAction\" could be either, \"imBack\", \"messageBack\", or \"postBack\".\nexport default ({ cardAction }) => {\n  switch (cardAction.type) {\n    case 'messageBack':\n      return <MessageBackButton cardAction={cardAction} />;\n\n    case 'postBack':\n      return <PostBackButton cardAction={cardAction} />;\n\n    default:\n      return <ImBackButton cardAction={cardAction} />;\n  }\n};\n","import { hooks } from 'botframework-webchat-component';\nimport React from 'react';\n\nimport CardActionButton from './CardActionButton';\n\nconst { useSuggestedActions } = hooks;\n\n// Web Chat cleaned up the suggestedActions for us.\n// If the last activity is from the bot and contains \"suggestedActions\", Web Chat will send it to us thru \"suggestedActions\".\nconst SuggestedActions = () => {\n  const suggestedActions = useSuggestedActions();\n\n  return (\n    !!suggestedActions.length && (\n      <ul>\n        {suggestedActions.map((cardAction, index) => (\n          <li key={index}>\n            <CardActionButton cardAction={cardAction} />\n          </li>\n        ))}\n      </ul>\n    )\n  );\n};\n\nexport default SuggestedActions;\n","// This function will follow a path to get a value from an object.\n// If the path leads to \"undefined\", we will return \"undefined\" instead.\nexport default function getValueOrUndefined(object, ...path) {\n  if (typeof object !== 'undefined' && path.length) {\n    const key = path.shift();\n\n    return getValueOrUndefined(object[key], ...path);\n  } else {\n    return object;\n  }\n}\n","import { hooks } from 'botframework-webchat-component';\nimport React, { useCallback, useState } from 'react';\n\nimport Attachment from './Attachment';\nimport SuggestedActions from './SuggestedActions';\n\nimport getValueOrUndefined from './util/getValueOrUndefined';\n\nconsole.log(hooks);\nconst { useActivities, useSendMessage } = hooks;\n\nconst PlainWebChat = () => {\n  const [activities] = useActivities();\n  const sendMessage = useSendMessage();\n\n  const [sendBoxValue, setSendBoxValue] = useState('');\n\n  const handleChange = useCallback(({ target: { value } }) => setSendBoxValue(value), [setSendBoxValue]);\n\n  const handleSubmit = useCallback(\n    event => {\n      event.preventDefault();\n\n      sendMessage(sendBoxValue);\n      setSendBoxValue('');\n    },\n    [sendBoxValue, sendMessage, setSendBoxValue]\n  );\n\n  return (\n    <div>\n      <ul>\n        {activities\n          // Currently, this sample only displays an activity of type \"message\"\n          .filter(({ type }) => type === 'message')\n          // We need to hide \"postBack\" message sent by the user\n          .filter(({ channelData: { postBack } = {}, from: { role } }) => !(role === 'user' && postBack))\n          // Normalize the activity:\n          // - Every activity should have an \"attachments\" array, consisting of zero or more attachments:\n          // - If this is a \"messageBack\" message, we should use the \"displayText\",\n          //   because \"text\" is being submitted to bot, and \"displayText\" is what we use to override what the bot displays to the user.\n          .map(activity => ({\n            ...activity,\n            attachments: activity.attachments || [],\n            text: getValueOrUndefined(activity, 'channelData', 'messageBack', 'displayText') || activity.text\n          }))\n          // Filter out all empty messages (no attachments or text)\n          .filter(({ attachments, text }) => attachments.length || text)\n          .map((activity, index) => (\n            <React.Fragment key={activity.id || index}>\n              <li>\n                {!!activity.text && (\n                  // We are using the very same component for text message and attachments.\n                  // This is because, attachments can also have \"text/markdown\" or \"text/plain\" content.\n                  // In this case, we prefer to have a single component for both of them.\n                  <Attachment\n                    content={activity.text}\n                    contentType={activity.textFormat === 'markdown' ? 'text/markdown' : 'text/plain'}\n                  />\n                )}\n                {!!activity.attachments.length && (\n                  <ul>\n                    {activity.attachments.map((attachment, index) => (\n                      <li key={index}>\n                        <Attachment {...attachment} />\n                      </li>\n                    ))}\n                  </ul>\n                )}\n              </li>\n            </React.Fragment>\n          ))}\n      </ul>\n      <div>\n        {/* This is the send box, and suggested actions change based on the send box, not activity */}\n        <SuggestedActions />\n        <form onSubmit={handleSubmit}>\n          <input autoFocus={true} onChange={handleChange} type=\"textbox\" value={sendBoxValue} />\n        </form>\n      </div>\n    </div>\n  );\n};\n\nexport default PlainWebChat;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (response.status === 404 || (contentType != null && contentType.indexOf('javascript') === -1)) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log('No internet connection found. App is running in offline mode.');\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","import { Components } from 'botframework-webchat-component';\nimport { createDirectLine } from 'botframework-webchat';\nimport React from 'react';\n\nimport PlainWebChat from './PlainWebChat';\n\n// In this demo, we are using Direct Line token from MockBot.\n// To talk to your bot, you should use the token exchanged using your Direct Line secret.\n// You should never put the Direct Line secret in the browser or client app.\n// https://docs.microsoft.com/en-us/azure/bot-service/rest-api/bot-framework-rest-direct-line-3-0-authentication\n\nasync function getDirectLineToken() {\n  const res = await fetch('https://webchat-mockbot.azurewebsites.net/directline/token', { method: 'POST' });\n  const { token } = await res.json();\n\n  return token;\n}\n\nexport default () => {\n  const [directLine, setDirectLine] = React.useState();\n\n  if (!directLine) {\n    // We will load DirectLineJS asynchronously on first render.\n    getDirectLineToken().then(token => setDirectLine(createDirectLine({ token })));\n  }\n\n  return (\n    // We are using the \"Composer\" component here, which all descendants will have access to the Web Chat API by HOC-ing thru \"connectToWebChat\".\n    <React.Fragment>\n      <h1>Web Chat with plain UI</h1>\n      <p>\n        This sample shows how to use Web Chat without any of its canned UI component. There are few conversation you can\n        try out.\n      </p>\n      <ol>\n        <li>\n          Say <code>image</code> to the bot\n        </li>\n        <li>\n          Say <code>suggested-actions</code> to the bot\n        </li>\n        <li>\n          Say <code>card bingsports</code> to the bot\n        </li>\n      </ol>\n      <p>\n        For the{' '}\n        <a href=\"https://github.com/microsoft/BotFramework-WebChat/tree/master/samples/21.customization-plain-ui/\">\n          source code of this demo\n        </a>\n        , please visit <a href=\"https://github.com/microsoft/BotFramework-WebChat/\">our GitHub repository</a>.\n      </p>\n      <hr />\n      {!!directLine && (\n        <Components.Composer directLine={directLine}>\n          <PlainWebChat />\n        </Components.Composer>\n      )}\n    </React.Fragment>\n  );\n};\n"],"sourceRoot":""}